
%% Calculate pupil from ray tracing
%
% The lens is samples for multiple off-axis positions. At each off
% axis-position the domain of rays that pass (entrance pupil) will vary and
% be described by the intersection of 3 circles. This script aims to
% automatically estimate the 3 circles.


% Thomas Goossens

%% Load lens file
clear;close all;

lensFileName = fullfile('dgauss.22deg.50.0mm_aperture6.0.json');

exist(lensFileName,'file');


lens = lensC('fileName', lensFileName)



disp('Lens NOT reversed')
lens.draw


    
%Set diaphraghm diameter. Should be smaller than 9  to find the exit pupil
%in this case
diaphragm_diameter= 7;
lens = lensC('fileName', lensFileName)



disp('Lens NOT reversed')
lens.draw


    


    
%Set diaphraghm diameter. Should be smaller than 9  to find the exit pupil
%in this case
diaphragm_diameter= 7;
lens = lensC('fileName', lensFileName)



disp('Lens NOT reversed')
lens.draw


    
%Set diaphraghm diameter. Should be smaller than 9  to find the exit pupil
%in this case
diaphragm_diameter= 7;
lens.surfaceArray(6).apertureD=diaphragm_diameter;
lens.apertureMiddleD=diaphragm_diameter;

%% INput plane

firstEle=lens.surfaceArray(1); % First lens element
firstsurface_z = firstEle.sCenter(3)-firstEle.sRadius; % Seems working, but why
    
offset_inputplane=0.01;%mm
inputplane_z= firstsurface_z-offset_inputplane

%% Choose entrance pupil position w.r.t. input plane
% Ideally this distance is chosen in the plane in which the entrance pupil
% doesn't shift.  
% This is the best guess. In principle the algorithm can handle  an unknown
% entrancepupil distance

% Good guess:
entrancepupil_distance =  17;

% Bad guess: , 
%entrancepupil_distance =  3;
%entrancepupil_distance=  0.5;


%% Define Bounding box
boundingBoxZ = firstsurface_z;
boundingBoxWidth = 30


%% Run ray trace, and log which rays can pass
clear p;

flag_runraytrace=true;

if(not(flag_runraytrace))
    % IF we don't want to redo all the ray trace, load a cached ray trace
    % file. This file was generated by just using save('./cache/...')
        
    %load('./cache/dgauss.22deg.50.0mm_aperture6.0.json-offset0.01-September-29-2021_ 3-28PM.mat') % Forward lens
    load('/home/thomas42/Documents/MATLAB/libs/isetlens/scripts/equivalentlens/RTF/examples/dgauss50mm/cache/dgauss.22deg.50.0mm_aperture6.0.json-offset0.01scenetofilm-October-12-2021_ 2-47PM.mat')
else
     
    % Ray trace sampling parameters
  

 %lens forward
 positions=[0 1 2 3 4 5 6 7 8 9 10 10.1 10.2 10.3 10.4 10.5 11 12 12.5 13 13.5 14 15 16 17];
 
 % Lens reverse
% positions =[0    1.0000    2.0000    3.0000    4.0000    5.0000    6.0000    7.0000    8.0000    9.0000   10.0000   10.1000   10.2000 10.3000   10.4000   10.5000];
 
 

    
    % Initiate the arrays as NaNs, else the zeros will be interpreted at a
    % position for which a ray passed
    nbThetas=500;
    nbPhis=500;
    pupilshape_trace = nan(3,numel(positions),nbThetas,nbPhis);
    
    
    
    for p=1:numel(positions)
        disp(['positions: ' num2str(p)])
        maxTheta=60;
        nbPhis=nbThetas;
        thetas = linspace(0,maxTheta,nbThetas);
        phis = linspace(0,359,nbPhis);

        
        count=1;
        for ph=1:numel(phis)
                        
            for t=1:numel(thetas)
                
                % Origin of ray
                origins(count,:) = [0;positions(p);inputplane_z];
                
                
                % Direction vector of ray
                phi=phis(ph);
                theta=thetas(t);
                
                
                directions(count,:) = [sind(theta).*cosd(phi);  sind(theta)*sind(phi) ; cosd(theta)];
                
                count=count+1;
            end
        end
        
        
                % Trace ray with isetlens
                
                 waveIndices=1*ones(1, size(origins, 1));
                rays = rayC('origin',origins,'direction', directions, 'waveIndex', waveIndices, 'wave', lens.wave);
                [~, ~, pOut, pOutDir] = lens.rtThroughLens(rays, rays.get('n rays'), 'visualize', false);
                
                pass_trace = not(isnan(prod(pOut,2)));    
    
                % If the ray passes the lens, save at which coordinate it
                % intersected with the chosen pupil plane.
                
                count=1;
                for i=1:numel(pass_trace)
                    if(pass_trace(i))
                    % Linear extrapolation from origin to find intersection
                    % with entrance_pupil plane
                    pointOnPupil = origins(i,:)+(entrancepupil_distance/(directions(i,3)))*directions(i,:);
                    
                    pupilshape_trace(:,p,count)=  pointOnPupil;
                    count=count+1;
                    end
                end
                
            end
        end
    
    
    % Save the ray trace, because hey, it takes a long time!
    close all;
    save(['./cache/' lensFileName '-offset' num2str(offset_inputplane) 'scenetofilm-' datestr(now,'mmmm-dd-yyyy_HH-MMAM') '.mat'])





%% Step 1 : Fit exit pupil on-axis.   
% At the onaxis position (p=1), there is no vignetting, and by construciton
% the pupil you see is the entrance pupil. The radius is estimated by
% finding the minimally bounding circle (using the toolbox)

p=1
Ptrace=pupilshape_trace(1:2,p,:);
Ptrace=Ptrace(1:2,:);

NaNCols = any(isnan(Ptrace));
Pnan = Ptrace(:,~NaNCols);
ZeroCols = any(Pnan(:,:)==[0;0]);
Pnan = Pnan(:,~ZeroCols);

[center0,radius0] = minboundcircle(Pnan(1,:)',Pnan(2,:)')

figure(1);clf; hold on;
viscircles(center0,radius0)
scatter(Ptrace(1,:),Ptrace(2,:),'.')



%% Step 1: Automatic entrance puil
% When the exit pupil distance is not exactly known, we also need to
% estimate a sensitivity for the entrance pupil as it will not remaind
% stationairy.
% The top part is used because (at least for dgauss) this is the last
% surface to be cut off

% Top

for p = 3:22
offaxis_distances=positions(p);

offset=0.06;
stepsize_radius=0.1;
[radius_top,sensitivity_top]=findCuttingCircleEdge(pupilshape_trace(1:2,p,:),offaxis_distances,"top",'offset',offset,'stepsizeradius',stepsize_radius);
[radius_bottom,sensitivity_bottom]=findCuttingCircleEdge(pupilshape_trace(1:2,p,:),offaxis_distances,"bottom",'offset',offset,'stepsizeradius',stepsize_radius);

radii_top(p)=radius_top;
radii_bottom(p)=radius_bottom;
sensitivities_top(p)=sensitivity_top;
sensitivities_bottom(p)=sensitivity_bottom;
end

%%

figure(10);clf; 
subplot(211);hold on
plot(radii_top,'r.-');
plot(radii_bottom,'k.-');
subplot(212);hold on
plot(sensitivities_top,'r.-');
plot(sensitivities_bottom,'k.-');


%% Circle information for PBRT RTF



circleRadii = [radii_top radii_bottom]
circleSensitivities = [sensitivities_top sensitivities_bottom]
circlePlaneZ=entrancepupil_distance


%% Prune


%% Verify automatic fits:
colors={'k' 'r' 'g' 'b' 'm' [0.9 0.5 0.9] };

figure(1);clf; hold on;
for p=1:numel(positions)
    subplot(2,round(numel(positions)/2),p); hold on;
 
       % Collected points
    Ptrace=pupilshape_trace(1:2,p,:);
    Ptrace=Ptrace(1:2,:);
    scatter(Ptrace(1,:),Ptrace(2,:),'.')
    
    
    
    for c=1:numel(circleRadii)
        % Calculate offset of each circle
         offset=circleSensitivities(c)*positions(p);
          
         % Draw circles
         viscircles([0 offset],circleRadii(c),'color','k','linewidth',1)
    end
    
     % Draw off axis position
     scatter(0,positions(p))
     
 
     
     
    xlim(3*radius0*[-1 1])
    ylim(3*radius0*[-1 1])
    title(positions(p))
    %axis equal
    %pause(0.5);
    
 
    
end



return
%% Calculate pupil positions and radii
% To be used in 'checkRayPassLens'
% All circle intersections where done in the entrance pupil plane.
% Each circle is a projection of an actual pupil. Here I project the
% corresponding circles back to their respective plane where they are
% centered on the optical axis.

% Distance to entrance pupil is already known by construction unless a
% wrong guess was taken. When the guess was good sensitivity_entrance
% should be basically zero.
hx= entrancepupil_distance/(1-(sensitivity_entrance))
Rpupil_entrance = radius_entrance/(1-sensitivity_entrance)

% Calculate radius of a pupil by projecting it back to its actual plane
% (where it is cented on the optical axis)
Rpupil_bottom = radius_bottom/(1-sensitivity_bottom)
Rpupil_top = radius_top/(1-sensitivity_top)


% Calculate positions of pupils relative to the input plane
hp_bottom=entrancepupil_distance/(1-sensitivity_bottom)
hp_top=entrancepupil_distance/(1-sensitivity_top)


% Information to be used for PBRT domain evaluation (FOR ZHENG)
radii = [Rpupil_entrance Rpupil_bottom Rpupil_top]
pupil_distances = [hx, hp_bottom hp_top]

%
% %%
% radii =
%
%     0.4698    4.3275    0.5991
% 
% 
% pupil_distances =
% 
% 1.1480   10.3072    0.1570
% 

%% Second Verification (to check the ebove equations)
fig=figure(10);clf

fig.Position(3:4)=[938 362]

for p=1:numel(positions)    
    subplot(2,ceil(numel(positions)/2),p); hold on;
    
        
    % Plot traced pupil shape
    Ptrace=pupilshape_trace(1:2,p,:);
    Ptrace=Ptrace(1:2,:);
    scatter(Ptrace(1,:),Ptrace(2,:),'.')
    
    
    lw=2; %Linewidth
    
    % Draw entrance pupil
    sensitivity = (1-entrancepupil_distance/hx);
    dentrance=sensitivity*positions(p);
    projected_radius = abs(entrancepupil_distance/hx)*Rpupil_entrance;
    viscircles([0 dentrance],projected_radius,'color','k','linewidth',lw)
    
    % Draw Bottom circle
    sensitivity = (1-entrancepupil_distance/hp_bottom);
    dvignet=sensitivity*positions(p);
    projected_radius = abs(entrancepupil_distance/hp_bottom)*Rpupil_bottom;
    viscircles([0 dvignet],projected_radius,'color',[0 0 0.8],'linewidth',lw)
    
    
    % Draw Top circle
    sensitivity = (1-entrancepupil_distance/hp_top);
    dvignet=sensitivity*positions(p);
    projected_radius = abs(entrancepupil_distance/hp_top)*Rpupil_top;
    viscircles([0 dvignet],projected_radius,'color',[0.8 0 0 ],'linewidth',lw)
    
    
    %axis equal
    ylim(20*[-1 1])
    xlim(20*[-1 1])
    
   
    ax=gca;
    ax.XAxis.Visible='off';
    ax.YAxis.Visible='off'; 
    
    
    title(['p = ' num2str(positions(p)) ' mm'])
end

saveas(gcf,'dgauss_threecircles.eps','epsc')



%%%

%% Check pass
% Ray trace sampling parameters
nbThetas=40;
nbPhis=nbThetas;
thetas = linspace(-40,40,nbThetas);
phis = linspace(0,359,nbPhis);

counter=1;
for p=1:numel(positions)
    p
    for ph=1:numel(phis)
        for t=1:numel(thetas)
            
            % Origin of ray
            origin = [0;positions(p);inputplane_z];
            
            
            % Direction vector of ray
            phi=phis(ph);
            theta=thetas(t);
            direction = [sind(theta).*cosd(phi);  sind(theta)*sind(phi) ; cosd(theta)];
            
            % Trace ray with isetlens
            wave = lens.get('wave');
            rays = rayC('origin',origin','direction', direction', 'waveIndex', 1, 'wave', wave);
            [~,~,out_point,out_dir]=lens.rtThroughLens(rays,1,'visualize',false);
            pass_trace = not(isnan(prod(out_point)));
            pass_circle =checkRayPassLens(origin,direction, pupil_distances,radii);
            
            comparison(counter,1:2) = [pass_trace pass_circle];
            
            counter=counter+1;
        end
    end
end


%% Calculate Pass/Fail accuracy
% Depending on sampling it gets about 99 % correct  Realize this is heavily
% skewed if you are sampling far from the edges of the aperture anyway. But
% as long we consistently compare different passray functions we should be
% fine.

passratio=sum((comparison(:,1)==comparison(:,2)))/size(comparison,1)


%% Convex hull for each position

figure(1);clf;

for p=1:numel(positions)
    subplot(2,numel(positions)/2,p); hold on;
    points=squeeze(pupilshape_trace(1:2,p,:));
    points(:,isnan(points(1,:)))=[];
    [k,av]=convhull(points')
    hull{p}=points(:,k);
    
    
    plot(points(1,k),points(2,k))

    axis equal
        
    % random points check
    X=randn(2,100); 
    h1=hull{p};
     in = inpolygon(X(1,:)',X(2,:)',h1(1,:)',h1(2,:)');
    plot(X(1,in),X(2,in),'g+') % points inside
    plot(X(1,~in),X(2,~in),'r+') % points outside
    
    ylim([-2 2])
    xlim([-2 2])
    
end
%%
h1=hull{1}
x_test=0;
y_test=0;
tic; in = inpolygon(X(1,:)',X(2,:)',h1(1,:)',h1(2,:)');toc
tic; IN = inhull(X',h1');toc
