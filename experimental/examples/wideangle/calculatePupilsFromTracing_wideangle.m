%% Calculate pupil from ray tracing
%
% The lens is samples for multiple off-axis positions. At each off
% axis-position the domain of rays that pass (entrance pupil) will vary and
% be described by the intersection of 3 circles. This script aims to
% automatically estimate the 3 circles.


% Thomas Goossens

%% Load lens file
clear;close all;

lensFileName = fullfile('wide.56deg.3.0mm.json');
exist(lensFileName,'file');


lens = lensC('fileName', lensFileName)
lens=lensReverse(lensFileName);
lens.draw

%% INput plane

firstEle=lens.surfaceArray(1); % First lens element
firstsurface_z = firstEle.sCenter(3)-firstEle.sRadius; % Seems working, but why
    
offset_inputplane=0.1;%mm
inputplane_z= firstsurface_z-offset_inputplane

%% Modifcation of lens parameters if desired
% I shouldn't have done this perhaps

% diaphragm_diameter=0.6;
% lens.surfaceArray(6).apertureD=diaphragm_diameter;
% lens.apertureMiddleD=diaphragm_diameter;


%% Choose entrance pupil position w.r.t. input plane
% Ideally this distance is chosen in the plane in which the entrance pupil
% doesn't shift.  
% This is the best guess. In principle the algorithm can handle  an unknown
% entrancepupil distance

% Good guess:
entrancepupil_distance =  1.1439;

% Bad guess: , 
%entrancepupil_distance =  3;
%entrancepupil_distance=  0.5;

%% Run ray trace, and log which rays can pass
clear p;

flag_runraytrace=false;
flag_savefile=true;

if(~flag_savefile)
disp('!!!Save file not enable!!! Do not come and cry')    
pause(3);
end

if(not(flag_runraytrace))
    % IF we don't want to redo all the ray trace, load a cached ray trace
    % file. This file was generated by just using save('./cache/...')
    
    load cache/wide.56deg.3.0mm.json-offset0.1-June-12-2021_4-07AM.mat;
    load 'cache/wide.56deg.3.0mm.json-offset0.1-June-15-2021_ 1-14AM.mat';
else
     
    % Ray trace sampling parameters
    nbThetas=100;
    nbPhis=nbThetas;
    thetas = linspace(-70,70,nbThetas);
    phis = linspace(0,359,nbPhis);

    positions=[0 0.1 0.3 0.5 0.6 0.64 0.7 0.8 0.9 1 1.2 1.3 1.5 1.8 1.9 2 2.1 2.2 2.3 2.4 2.5]
    positions=[0 1.9 2 2.1 2.2 2.3 2.4 2.5]
    %positions=[0 0.5]
        
    % Initiate the arrays as NaNs, else the zeros will be interpreted at a
    % position for which a ray passed
    pupilshape_trace = nan(3,numel(positions),numel(thetas),numel(phis));
    
    for p=1:numel(positions)
        p
        for ph=1:numel(phis)
            for t=1:numel(thetas)
                
                % Origin of ray
                origin = [0;positions(p);inputplane_z];
                
                
                % Direction vector of ray
                phi=phis(ph);
                theta=thetas(t);
                direction = [sind(theta).*cosd(phi);  sind(theta)*sind(phi) ; cosd(theta)];
                
                
                % Trace ray with isetlens
                wave = lens.get('wave');
                rays = rayC('origin',origin','direction', direction', 'waveIndex', 1, 'wave', wave);
                [~,~,out_point,out_dir]=lens.rtThroughLens(rays,1,'visualize',false);
                pass_trace = not(isnan(prod(out_point)));
                
                % If the ray passes the lens, save at which coordinate it
                % intersected with the chosen pupil plane.
                if(pass_trace)
                    % Linear extrapolation from origin to find intersection
                    % with entrance_pupil plane
                    pointOnPupil = origin+(entrancepupil_distance/(direction(3)))*direction;
                    
                    pupilshape_trace(:,p,t,ph)=  pointOnPupil;
                end
                
            end
        end
    end
    
    % Save the ray trace, because hey, it takes a long time!
    close all;
    if(flag_savefile)
      save(['./cache/' lensFileName '-offset' num2str(offset_inputplane) '-' datestr(now,'mmmm-dd-yyyy_HH-MMAM') '.mat'])
    end
end


%% Visualize 2D
p=2
Ptrace=pupilshape_trace(1:2,p,:);
Ptrace=Ptrace(1:2,:);
figure;scatter(Ptrace(1,:),Ptrace(2,:),'.')


%% 2D Trace along line to accurately find borders of the pupils
% In 3D you might easily undersample such that the most extreme points are
% lost. We assume here that these extreme points must lie on the center,
% and hence we can find them by sampling many more angles along one line.
nbThetas=600;
nbPhis=nbThetas;
thetas = linspace(-40,40,nbThetas);






%% Step 1 : Fit exit pupil on-axis.   
% At the onaxis position (p=1), there is no vignetting, and by construciton
% the pupil you see is the entrance pupil. The radius is estimated by
% finding the minimally bounding circle (using the toolbox)

p=1
Ptrace=pupilshape_trace(1:2,p,:);
Ptrace=Ptrace(1:2,:);

NaNCols = any(isnan(Ptrace));
Pnan = Ptrace(:,~NaNCols);
ZeroCols = any(Pnan(:,:)==[0;0]);
Pnan = Pnan(:,~ZeroCols);

[center0,radius0] = minboundcircle(Pnan(1,:)',Pnan(2,:)')

figure(1);clf; hold on;
viscircles(center0,radius0)
scatter(Ptrace(1,:),Ptrace(2,:),'.')






%% Step 1: Automatic entrance puil
% When the exit pupil distance is not exactly known, we also need to
% estimate a sensitivity for the entrance pupil as it will not remaind
% stationairy.
% The top part is used because (at least for dgauss) this is the last
% surface to be cut off

% Top
position_selection=[3]; % Choose the positions for which the top circle is unaffected by vignetting.
offaxis_distances=positions(position_selection);


offset=0.01;
stepsize_radius=0.01;
[radius_entrance,sensitivity_entrance]=findCuttingCircleEdge(pupilshape_trace(1:2,position_selection,:),offaxis_distances,"top",'offset',offset,'stepsizeradius',stepsize_radius)
radius_entrance=radius0
radius_entrance=0.1276
disp('radius entrance manually set!!!')
%% Step 2: Automatic estimation of the vignetting circles
% The automatic estimation algorithm tries to fit a circle that matches the
% curvature and position on opposite (vertical) sides of the pupil.

% Bottom
position_selection=2:8;
offaxis_distances=positions(position_selection);
offset=0.01;
stepsize_radius=0.01;
[radius_bottom,sensitivity_bottom]=findCuttingCircleEdge(pupilshape_trace(1:2,position_selection,:),offaxis_distances,"bottom",'offset',offset,'stepsizeradius',stepsize_radius)

%% Top
position_selection=6:7;
offaxis_distances=positions(position_selection);
offset=0.0022;
stepsize_radius=0.01;
[radius_top,sensitivity_top]=findCuttingCircleEdge(pupilshape_trace(1:2,position_selection,:),offaxis_distances,"top",'offset',offset,'stepsize radius',stepsize_radius)


%

%% Verify automatic fits:


figure(1);clf; hold on;
for p=1:numel(positions)
    subplot(2,round(numel(positions)/2),p); hold on;
    Ptrace=pupilshape_trace(1:2,p,:);
    Ptrace=Ptrace(1:2,:);
    
    scatter(Ptrace(1,:),Ptrace(2,:),'.')
    
%     % Calculate offset of each circle
     offset_entrance=sensitivity_entrance*positions(p);
     offset_bottom=sensitivity_bottom*positions(p);
     offset_top=sensitivity_top*positions(p);
     
     % Draw circles
     %    viscircles(center0,radius0,'color','k')
     viscircles([0 offset_entrance],radius_entrance,'color','k','linewidth',1)
     viscircles([0 offset_bottom],radius_bottom,'color','b','linewidth',1);
     viscircles([0 offset_top],radius_top,'color','r','linewidth',1);
     
     ellipse_sensitivty=0.2
     radius_y=radius_entrance*(1+ellipse_sensitivty*positions(p));
     ellipse(radius_entrance,radius_y,0,0,offset_entrance,'m')
     
    xlim(5*radius_entrance*[-1 1])
    ylim(radius_entrance*[-2 6])
    title(positions(p))
    axis equal
    %pause(0.5);
    
    
end


%% Calculate pupil positions and radii
% To be used in 'checkRayPassLens'
% All circle intersections where done in the entrance pupil plane.
% Each circle is a projection of an actual pupil. Here I project the
% corresponding circles back to their respective plane where they are
% centered on the optical axis.

% Distance to entrance pupil is already known by construction unless a
% wrong guess was taken. When the guess was good sensitivity_entrance
% should be basically zero.
hx= entrancepupil_distance/(1-(sensitivity_entrance))

Rpupil_entrance = radius_entrance/(1-sensitivity_entrance)


% Calculate positions of pupils relative to the input plane
hp_bottom=entrancepupil_distance/(1-sensitivity_bottom)
hp_top=entrancepupil_distance/(1-sensitivity_top)


% Calculate radius of a pupil by projecting it back to its actual plane
% (where it is cented on the optical axis)
Rpupil_bottom = radius_bottom/(1-sensitivity_bottom)
Rpupil_top = radius_top/(1-sensitivity_top)



% Information to be used for PBRT domain evaluation (FOR ZHENG)
radii = [Rpupil_entrance Rpupil_bottom Rpupil_top]
pupil_distances = [hx, hp_bottom hp_top]

%
% %%
% radii =
%
%     0.4698    4.3275    0.5991
% 
% 
% pupil_distances =
% 
% 1.1480   10.3072    0.1570
% 

%% Second Verification (to check the ebove equations)
figure;

for p=1:numel(positions)    
    subplot(2,ceil(numel(positions)/2),p); hold on;
    
        
    % Plot traced pupil shape
    Ptrace=pupilshape_trace(1:2,p,:);
    Ptrace=Ptrace(1:2,:);
    scatter(Ptrace(1,:),Ptrace(2,:),'.')
    
    
    % Draw entrance pupil
    sensitivity = (1-entrancepupil_distance/hx);
    dentrance=sensitivity*positions(p);
    projected_radius = abs(entrancepupil_distance/hx)*Rpupil_entrance;
    viscircles([0 dentrance],projected_radius,'color','k','linewidth',1)
    
    % Draw Bottom circle
    sensitivity = (1-entrancepupil_distance/hp_bottom);
    dvignet=sensitivity*positions(p);
    projected_radius = abs(entrancepupil_distance/hp_bottom)*Rpupil_bottom;
    viscircles([0 dvignet],projected_radius,'color','b','linewidth',1)
    
    
    % Draw Top circle
    sensitivity = (1-entrancepupil_distance/hp_top);
    dvignet=sensitivity*positions(p);
    projected_radius = abs(entrancepupil_distance/hp_top)*Rpupil_top;
    viscircles([0 dvignet],projected_radius,'color','r','linewidth',1)
    
    %axis equal
    ylim(2*[-1 1])
    xlim(2*[-1 1])
    title(['x = ' num2str(positions(p))])
end


